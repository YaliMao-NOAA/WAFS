#!/bin/bash
######################################################################
# Start point of doing WAFS regression test
# Yali Mao Sept 2021
#
# Each WAFS job runs on a single CPU or MPMD, so no regression test for
# different CPUs.
#
######################################################################
# WAFS regression test plan (fixed PDY CYC FHOUR) includes:
#=====================================================================
# (Under working folder, log/rt.log.$machine)
# Runtime summary (include the operational runtime)
# What files are compared (including wmo files), and there are 3 different types of results:
#   - Fails generating file
#   - Bitwise identical file
#   - Not bitwise identical file (check diff reports as below, generated by cmp_grib2_grib2)
#
# (Under working folder, gfs.$PDY/*diff)
# If not bitwise identical, check diff reports:
#   - When fields have no difference, the diff file size is zero.
#   - When one file is a subset of the other, list:
#     File sizes
#     Fields/records side by side to make sure two files have the same fields in the same order.
#   - When fields are different, list:
#     Reports of RMSE and Correlation Coefficient
#     File sizes
#     Fields/records side by side to make sure two files have the same fields in the same order.
#     . It catches the error when the underground masks are wrongly mirrored along the equator
#       (The diff report file has a pattern that lower level has worse matching than the upper level,
#        and the fields have no difference at levels above 500mb)
#     . It catches the error of the constant heights by file size difference.
# 
# Compare to operational products
# Compare to UK's products (optional)
# Compare to data confirmed by AWC, or others.
#
# (Optional, manually)
# Plots
#
######################################################################
# Changes in the future
#=====================================================================
# input/output filename changes
#   prepare_data.sh
#   $filelist in drivers
#
# UK blended data included or not for comparison
#   prepare_data.sh : save to data_out
#   $fileUK in drivers
#
# Different versions have different drivers and different data sets
#
######################################################################
# Variables to be customized by developers
#=====================================================================
# test_v=
# build_exe=
# cmake=yes
#
# joblist=
# Specify packages to test, a full list:
# joblist="grib2_1p25 blend_1p25 grib2_0p25 blend_0p25 gcip"
# grib2_1p25 : grib2 at 1.25 degree
# blend_1p25 : blending at 1.25 degree
# grib2_0p25 : grib2 at 0.25 degree
# blend_0p25 : blending at 0.25 degree
# gcip : gcip
#
# workdir=
# logfile=
#
######################################################################

set -x

# WAFS inventory copy to be regression-tested
export test_v=/gpfs/dell2/emc/modeling/noscrub/Yali.Mao/git/EMC_wafs.work.v6

# Build WAFS executable files or not
build_exe=no
# Is it cmake version? (yes/no)
cmake=no

# Specify packages to test:
joblist="grib2_1p25 blend_1p25 grib2_0p25 blend_0p25"
#joblist="grib2_0p25 blend_0p25"
#joblist="grib2_1p25 blend_1p25"

#load module
module load prod_util/1.1.0

# find machine
mac=$(hostname | cut -c1-1)
if [ $mac = v -o $mac = m  ] ; then   # WCOSS_D (venus and mars)
  export machine=dell
  export basedir=/gpfs/dell2/emc/modeling/noscrub/Yali.Mao/git/regression_wafs
  export workdir=/gpfs/dell3/ptmp/$USER/regression_wafs
  export cmp_grib2_grib2=/u/Yali.Mao/bin/cmp_grib2_grib2_new # 0: different 1: same
fi

mkdir -p $workdir/log

#set log file
export logfile=$workdir/log/rt.log.$machine
if [ -f $logfile ] ; then
  rm -r $logfile
fi

# Pre-saved runtime baseline
runtime_log=$basedir/fix/runtime.log.$machine

#build executable
if [ "$build_exe" = "yes" ]; then
  cd ${test_v}/sorc
  if [ $cmake = "yes" ] ; then
      sh build_wafs_cmake.sh
  else
      sh build_wafs.sh
  fi
  status=$?
  if [ $status -eq 0 ]; then
    msg="Building executable successfully" 
  else
    msg="Building executable with failure"
    exit
  fi
  postmsg "$logfile" "$msg"
fi

jobid_list=""

cd $workdir
for ajob in $joblist ; do
  # grib2 G45 data at 1.25 degree
  if [ $ajob = "grib2_1p25" ]; then
     driver=run_JGFS_WAFS_GRIB2.${machine}
     outputfile=out.grib2_1p25.wafs
  # blending at 1.25 degree
  elif [ $ajob = "blend_1p25" ]; then
     driver=run_JGFS_WAFS_BLENDING.${machine}
     outputfile=out.blend_1p25.wafs
  # grib2 data at 0.25 degree
  elif [ $ajob = "grib2_0p25" ]; then
     driver=run_JGFS_WAFS_GRIB2_0P25.${machine}
     outputfile=out.grib2_0p25.wafs
  # blending at 0.25 degree
  elif [ $ajob = "blend_0p25" ]; then
     driver=run_JGFS_WAFS_BLENDING_0P25.${machine}
     outputfile=out.blend_0p25.wafs
  # GCIP
  elif [ $ajob = "gcip" ]; then
     driver=run_JGFS_WAFS_GCIP.${machine}
     outputfile=out.gcip.wafs
  fi

  if [ $cmake = "yes" ] ; then
      cp $basedir/driver/$driver .
  else
      cp $basedir/driver.v6/$driver .
  fi
  sed -e "s|^#BSUB -oo.*|#BSUB -oo $workdir/log/$outputfile|" \
      -e "s|^#BSUB -eo.*|#BSUB -eo $workdir/log/$outputfile|" \
      -e "s|^#BSUB -J.*|#BSUB -J $ajob|" -i $driver

  if   [[ $ajob = "blend_1p25" ]] && [[ $joblist =~ "grib2_1p25" ]] ; then
      # blend_1p25 is a downstream of grib2_1p25 
      status=`bsub -w "done(grib2_1p25)" < $driver`
  elif [[ $ajob = "blend_0p25" ]] && [[ $joblist =~ "grib2_0p25" ]]; then
      # blend_0p25 is a downstream of grib2_0p25 
      status=`bsub -w "done(grib2_0p25)" < $driver`
  else
      status=`bsub < $driver`
  fi
  job_id=`echo $status | cut -d'<' -f2|cut -d'>' -f1`
  jobid_list="$jobid_list $job_id"
done

#get run time for each test
for job_id in $jobid_list; do
  ic=1
  sleep_loop_max=200
  while [ $ic -le $sleep_loop_max ]; do
     status=`bjobs ${job_id} | awk 'FNR == 2' | awk '{print $3}'`
     if [ "$status" = "DONE" ]; then
       break
     elif [ "$status" = "EXIT" ]; then
       break
     else
      ic=`expr $ic + 1`
      sleep 15
     fi
  done
  if [ $ic -lt $sleep_loop_max ]; then
     runtime=`bhist ${job_id} | awk 'FNR == 3' | awk '{print $6}'`
     jobname=`bhist -w ${job_id} | awk 'FNR == 3' | awk '{print $3}'`
     runtime_b=`grep ${jobname} ${runtime_log} | awk '{print $2}' `
     echo "$runtime   $jobname ${runtime_b}"
     msg="Runtime: $jobname $runtime -- baseline ${runtime_b}"
     postmsg "$logfile" "$msg"
  fi
done
